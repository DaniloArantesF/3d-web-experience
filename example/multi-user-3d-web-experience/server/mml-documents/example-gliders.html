<m-group id="conway-frame"></m-group>
<m-group id="cubes-group"></m-group>

<script>
  const cubesGroup = document.getElementById("cubes-group");
  const conwayFrame = document.getElementById("conway-frame");
  const resetButton = document.createElement("m-label");

  let world = [];
  const worldSize = 12;
  const cellSize = 0.5;
  const spawnChance = 0.3333334;
  let stepCount = 0;

  function createBorder(side) {
    const sy = side === "top" || side === "bottom" ? 0.5 : worldSize / 2;
    const sz = sy === 0.5 ? worldSize / 2 + 1 : 0.5;
    const pz =
      side === "left" ? -(worldSize / 4 + 0.25) : side === "right" ? worldSize / 4 + 0.25 : 0;
    const py =
      side === "top" ? worldSize / 2 + 0.75 : side === "bottom" ? 0.25 : worldSize / 4 + 0.5;
    const border = document.createElement("m-cube");
    border.setAttribute("color", "black");
    border.setAttribute("x", 0);
    border.setAttribute("y", py);
    border.setAttribute("z", pz);
    border.setAttribute("sx", 0.5);
    border.setAttribute("sy", sy);
    border.setAttribute("sz", sz);
    conwayFrame.appendChild(border);
  }

  createBorder("top");
  createBorder("bottom");
  createBorder("left");
  createBorder("right");

  const cubesMap = new Map();
  const statesHistory = new Set();

  function getID(x, y) {
    return `x:${x}-y:${y}`;
  }

  function initializeCubes() {
    for (let x = 0; x < worldSize; x++) {
      for (let y = 0; y < worldSize; y++) {
        let red = Math.floor((x / worldSize) * 255);
        let green = Math.floor((y / worldSize) * 255);
        let blue = 128;
        const redHex = ("0" + red.toString(16)).slice(-2);
        const greenHex = ("0" + green.toString(16)).slice(-2);
        const blueHex = ("0" + blue.toString(16)).slice(-2);
        const color = "#" + redHex + greenHex + blueHex;
        const cubeID = getID(x, y);
        const cube = document.createElement("m-cube");
        cube.id = cubeID;
        cube.setAttribute("id", cubeID);
        cube.setAttribute("x", 0);
        cube.setAttribute("y", cellSize * 2 + x * cellSize - cellSize / 2);
        cube.setAttribute("z", (y - worldSize / 2) * cellSize + cellSize / 2);
        cube.setAttribute("color", color);
        cube.setAttribute("sx", "0.5");
        cube.setAttribute("sy", "0.5");
        cube.setAttribute("sz", "0.5");
        cube.setAttribute("collide", false);
        cube.setAttribute("cast-shadows", false);
        cube.setAttribute("opacity", 0);
        cubesMap.set(cubeID, cube);
        cubesGroup.appendChild(cube);
      }
    }
  }

  function toggleCube(x, y, visible) {
    const cubeID = getID(x, y);
    const cube = document.getElementById(cubeID);
    cube.setAttribute("opacity", visible ? 1 : 0);
    cube.setAttribute("cast-shadows", visible ? true : false);
  }

  function createCube(x, y) {
    const cubeID = getID(x, y);
    const cubeToCreate = cubesMap.get(cubeID);
    cubeToCreate.setAttribute("opacity", 1);
    cubeToCreate.setAttribute("cast-shadows", true);
  }

  function deleteCube(x, y) {
    const cubeID = getID(x, y);
    const cubeToDelete = cubesMap.get(cubeID);
    if (cubeToDelete) {
      cubeToDelete.setAttribute("opacity", 0);
      cubeToDelete.setAttribute("cast-shadows", false);
    }
  }

  function initWorld() {
    for (let x = 0; x < worldSize; x++) {
      world[x] = [];
      for (let y = 0; y < worldSize; y++) {
        world[x][y] = Math.random() < spawnChance ? 1 : 0;
        toggleCube(x, y, world[x][y]);
      }
    }
  }

  function resetSimulation() {
    statesHistory.clear();
    for (let x = 0; x < worldSize; x++) {
      for (let y = 0; y < worldSize; y++) {
        world[x][y] = Math.random() < spawnChance ? 1 : 0;
        toggleCube(x, y, world[x][y]);
      }
    }
    stepCount = 0;
  }

  function update() {
    const newWorld = [];
    let hash = "";

    for (let x = 0; x < worldSize; x++) {
      newWorld[x] = [];
      for (let y = 0; y < worldSize; y++) {
        const nn = countNeighbours(x, y);
        const alive = world[x][y] === 1;
        if (alive && (nn < 2 || nn > 3)) {
          newWorld[x][y] = 0;
        } else if (!alive && nn === 3) {
          newWorld[x][y] = 1;
        } else {
          newWorld[x][y] = world[x][y];
        }

        hash += `${newWorld[x][y]}`;

        if (newWorld[x][y]) {
          if (!alive) createCube(x, y);
        } else if (alive) {
          deleteCube(x, y);
        }
      }
    }

    world = newWorld;
    stepCount++;

    if (statesHistory.has(hash)) {
      resetSimulation();
    } else {
      statesHistory.add(hash);
    }

    if (statesHistory.size > 2) {
      statesHistory.delete(statesHistory.values().next().value);
    }
  }

  function countNeighbours(x, y) {
    let count = 0;
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) {
          continue;
        }
        const nx = (x + dx + worldSize) % worldSize;
        const ny = (y + dy + worldSize) % worldSize;
        count += world[nx][ny];
      }
    }
    return count;
  }

  initializeCubes();
  initWorld();
  window.setInterval(update, 250);
</script>
